<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîß DEBUG COMPLETO - Sistema de Imagens</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .log-success { color: #10b981; }
        .log-error { color: #ef4444; }
        .log-warning { color: #f59e0b; }
        .log-info { color: #3b82f6; }
    </style>
</head>
<body class="bg-gray-900 text-white p-8">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-4xl font-bold mb-6">üîß DEBUG COMPLETO</h1>
        
        <!-- BOT√ïES -->
        <div class="grid grid-cols-2 gap-4 mb-8">
            <button onclick="testeUpload()" class="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded font-bold">
                1Ô∏è‚É£ TESTE UPLOAD
            </button>
            <button onclick="testeCache()" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded font-bold">
                2Ô∏è‚É£ TESTE CACHE
            </button>
            <button onclick="testeCarregarEmpresa()" class="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded font-bold">
                3Ô∏è‚É£ CARREGAR EMPRESA
            </button>
            <button onclick="testeCDN()" class="bg-orange-600 hover:bg-orange-700 px-6 py-3 rounded font-bold">
                4Ô∏è‚É£ TESTE CDN
            </button>
        </div>

        <!-- UPLOAD -->
        <div class="bg-gray-800 p-6 rounded-lg mb-6">
            <h2 class="text-2xl mb-4">üì§ Upload de Imagem</h2>
            <input type="file" id="fileInput" accept="image/*" class="bg-gray-700 p-2 rounded w-full mb-4">
            <div id="preview" class="mt-4"></div>
        </div>

        <!-- LOG -->
        <div class="bg-gray-800 p-6 rounded-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl">üìã Console Log</h2>
                <button onclick="limparLog()" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded text-sm">
                    Limpar
                </button>
            </div>
            <div id="logOutput" class="font-mono text-sm bg-black p-4 rounded max-h-96 overflow-y-auto"></div>
        </div>
    </div>

    <script>
        const TOKEN = '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';
        const OWNER = 'gasparfranciscogulungo';
        const REPO = 'gerador-declaracoes-data';
        const BRANCH = 'master';

        let ultimaImagemUrl = null;
        let ultimaImagemBase64 = null;

        // ====== LOGGING ======
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('logOutput');
            const time = new Date().toLocaleTimeString('pt-PT');
            const className = `log-${type}`;
            logDiv.innerHTML += `<div class="${className}">[${time}] ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }

        function limparLog() {
            document.getElementById('logOutput').innerHTML = '';
        }

        // ====== 1. TESTE UPLOAD ======
        async function testeUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                log('‚ùå Selecione um arquivo primeiro!', 'error');
                return;
            }

            log('üöÄ Iniciando teste de upload...', 'info');
            log(`üìÅ Arquivo: ${file.name} (${file.type})`, 'info');

            try {
                // Converter para base64
                const base64 = await fileToBase64(file);
                const base64Content = base64.split(',')[1];
                ultimaImagemBase64 = base64;
                
                log(`‚úÖ Base64 gerado: ${base64.substring(0, 50)}...`, 'success');

                // Upload para GitHub
                const filePath = `assets/test/${file.name}`;
                const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${filePath}`;
                
                log(`üì§ Enviando para: ${url}`, 'info');

                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${TOKEN}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: `Test upload ${file.name}`,
                        content: base64Content,
                        branch: BRANCH
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }

                const result = await response.json();
                const githubUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/${filePath}`;
                ultimaImagemUrl = githubUrl;

                log(`‚úÖ Upload conclu√≠do!`, 'success');
                log(`üîó URL: ${githubUrl}`, 'success');

                // Mostrar preview
                mostrarPreview(base64, githubUrl);

                // Salvar no cache
                await salvarNoCache(githubUrl, base64);

            } catch (error) {
                log(`‚ùå ERRO: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // ====== 2. TESTE CACHE ======
        async function testeCache() {
            log('üß™ Testando sistema de cache...', 'info');

            if (!ultimaImagemUrl) {
                log('‚ö†Ô∏è Fa√ßa upload de uma imagem primeiro!', 'warning');
                return;
            }

            try {
                // Limpar cache primeiro
                log('üóëÔ∏è Limpando cache...', 'info');
                await limparCache(ultimaImagemUrl);

                // Salvar no cache
                log('üíæ Salvando no cache...', 'info');
                await salvarNoCache(ultimaImagemUrl, ultimaImagemBase64);

                // Buscar do cache
                log('üì¶ Buscando do cache...', 'info');
                const cached = await buscarDoCache(ultimaImagemUrl);

                if (cached) {
                    log('‚úÖ Cache funcionando! Imagem recuperada.', 'success');
                    mostrarPreview(cached, ultimaImagemUrl);
                } else {
                    log('‚ùå Cache n√£o retornou imagem!', 'error');
                }

                // Estat√≠sticas
                const stats = await getCacheStats();
                log(`üìä Cache: ${stats.count} itens, ${stats.totalSizeMB} MB`, 'info');

            } catch (error) {
                log(`‚ùå ERRO: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // ====== 3. CARREGAR EMPRESA ======
        async function testeCarregarEmpresa() {
            log('üè¢ Carregando empresas do GitHub...', 'info');

            try {
                const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/data/empresas.json`;
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${TOKEN}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                const content = atob(result.content);
                const empresas = JSON.parse(content);

                log(`‚úÖ Empresas carregadas: ${empresas.empresas.length}`, 'success');

                if (empresas.empresas.length > 0) {
                    const primeira = empresas.empresas[0];
                    log(`üìã Primeira empresa: ${primeira.nome}`, 'info');
                    
                    if (primeira.logo) {
                        log(`üñºÔ∏è Logo URL: ${primeira.logo}`, 'info');
                        
                        // Tentar carregar logo
                        log('üì• Carregando logo do cache...', 'info');
                        const logoCache = await buscarDoCache(primeira.logo);
                        
                        if (logoCache) {
                            log('‚úÖ Logo encontrado no cache!', 'success');
                            mostrarPreview(logoCache, primeira.logo);
                        } else {
                            log('üì≠ Logo n√£o est√° no cache, baixando...', 'warning');
                            const logoData = await baixarImagemCDN(primeira.logo);
                            if (logoData) {
                                await salvarNoCache(primeira.logo, logoData);
                                mostrarPreview(logoData, primeira.logo);
                            }
                        }
                    } else {
                        log('‚ö†Ô∏è Primeira empresa n√£o tem logo', 'warning');
                    }
                }

            } catch (error) {
                log(`‚ùå ERRO: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // ====== 4. TESTE CDN ======
        async function testeCDN() {
            if (!ultimaImagemUrl) {
                log('‚ö†Ô∏è Fa√ßa upload primeiro!', 'warning');
                return;
            }

            log('üåê Testando disponibilidade no CDN...', 'info');
            log(`üîó URL: ${ultimaImagemUrl}`, 'info');

            const disponivel = await aguardarCDN(ultimaImagemUrl, 10, 1000);

            if (disponivel) {
                log('‚úÖ CDN dispon√≠vel!', 'success');
                const img = await baixarImagemCDN(ultimaImagemUrl);
                if (img) {
                    mostrarPreview(img, ultimaImagemUrl);
                }
            } else {
                log('‚ùå CDN n√£o disponibilizou imagem ap√≥s 10 tentativas', 'error');
            }
        }

        // ====== FUN√á√ïES AUXILIARES ======
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function aguardarCDN(url, maxRetries, delay) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, { method: 'HEAD', cache: 'no-cache' });
                    if (response.ok) {
                        log(`‚úÖ CDN dispon√≠vel ap√≥s ${i + 1} tentativas`, 'success');
                        return true;
                    }
                    log(`‚è≥ Tentativa ${i + 1}/${maxRetries}...`, 'info');
                } catch (e) {
                    log(`‚è≥ Tentativa ${i + 1}/${maxRetries} - Erro: ${e.message}`, 'warning');
                }
                await new Promise(r => setTimeout(r, delay));
            }
            return false;
        }

        async function baixarImagemCDN(url) {
            try {
                const response = await fetch(url, { cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                log(`‚ùå Erro ao baixar: ${error.message}`, 'error');
                return null;
            }
        }

        // ====== CACHE INDEXEDDB ======
        let db = null;

        async function initDB() {
            if (db) return db;

            return new Promise((resolve, reject) => {
                const request = indexedDB.open('GeradorPDF_ImageCache', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains('images')) {
                        const store = database.createObjectStore('images', { keyPath: 'url' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                };
            });
        }

        async function salvarNoCache(url, dataUrl) {
            await initDB();
            return new Promise((resolve) => {
                const tx = db.transaction(['images'], 'readwrite');
                const store = tx.objectStore('images');
                
                const data = {
                    url: url,
                    dataUrl: dataUrl,
                    timestamp: Date.now(),
                    size: dataUrl.length
                };
                
                store.put(data);
                tx.oncomplete = () => {
                    log(`üíæ Salvo no cache: ${(dataUrl.length / 1024).toFixed(2)} KB`, 'success');
                    resolve(true);
                };
                tx.onerror = () => {
                    log(`‚ùå Erro ao salvar cache`, 'error');
                    resolve(false);
                };
            });
        }

        async function buscarDoCache(url) {
            await initDB();
            return new Promise((resolve) => {
                const tx = db.transaction(['images'], 'readonly');
                const store = tx.objectStore('images');
                const request = store.get(url);
                
                request.onsuccess = () => {
                    if (request.result) {
                        log(`üì¶ Cache HIT: ${url.substring(0, 50)}...`, 'success');
                        resolve(request.result.dataUrl);
                    } else {
                        log(`üì≠ Cache MISS: ${url.substring(0, 50)}...`, 'warning');
                        resolve(null);
                    }
                };
            });
        }

        async function limparCache(url) {
            await initDB();
            return new Promise((resolve) => {
                const tx = db.transaction(['images'], 'readwrite');
                const store = tx.objectStore('images');
                store.delete(url);
                tx.oncomplete = () => resolve(true);
            });
        }

        async function getCacheStats() {
            await initDB();
            return new Promise((resolve) => {
                const tx = db.transaction(['images'], 'readonly');
                const store = tx.objectStore('images');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const items = request.result;
                    const totalSize = items.reduce((sum, item) => sum + (item.size || 0), 0);
                    resolve({
                        count: items.length,
                        totalSize: totalSize,
                        totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2)
                    });
                };
            });
        }

        function mostrarPreview(dataUrl, githubUrl) {
            const preview = document.getElementById('preview');
            preview.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-bold mb-2">üì∏ Preview Base64</h3>
                        <img src="${dataUrl}" class="max-w-full max-h-64 border-4 border-green-500 rounded">
                    </div>
                    <div>
                        <h3 class="font-bold mb-2">üåê Preview CDN</h3>
                        <img src="${githubUrl}" class="max-w-full max-h-64 border-4 border-blue-500 rounded">
                    </div>
                </div>
            `;
        }

        // Inicializar
        log('‚úÖ Sistema de debug carregado', 'success');
        log('üëâ Selecione uma imagem e clique em "TESTE UPLOAD"', 'info');
    </script>
</body>
</html>
